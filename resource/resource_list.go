// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package resource

import (
	"encoding/json"

	"github.com/aelsabbahy/goss/system"
	"github.com/codegangsta/cli"
)

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type AddrMap map[string]*Addr

func (r AddrMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Addr, system.Addr) {
	sysres := sys.NewAddr(sr, sys)
	res := NewAddr(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r AddrMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Addr, system.Addr, bool) {
	sysres := sys.NewAddr(sr, sys)
	res := NewAddr(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *AddrMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Addr
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type CommandMap map[string]*Command

func (r CommandMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Command, system.Command) {
	sysres := sys.NewCommand(sr, sys)
	res := NewCommand(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r CommandMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Command, system.Command, bool) {
	sysres := sys.NewCommand(sr, sys)
	res := NewCommand(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *CommandMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Command
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type DNSMap map[string]*DNS

func (r DNSMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*DNS, system.DNS) {
	sysres := sys.NewDNS(sr, sys)
	res := NewDNS(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r DNSMap) AppendSysResourceIfExists(sr string, sys *system.System) (*DNS, system.DNS, bool) {
	sysres := sys.NewDNS(sr, sys)
	res := NewDNS(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *DNSMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*DNS
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type FileMap map[string]*File

func (r FileMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*File, system.File) {
	sysres := sys.NewFile(sr, sys)
	res := NewFile(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r FileMap) AppendSysResourceIfExists(sr string, sys *system.System) (*File, system.File, bool) {
	sysres := sys.NewFile(sr, sys)
	res := NewFile(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *FileMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*File
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type GossfileMap map[string]*Gossfile

func (r GossfileMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Gossfile, system.Gossfile) {
	sysres := sys.NewGossfile(sr, sys)
	res := NewGossfile(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r GossfileMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Gossfile, system.Gossfile, bool) {
	sysres := sys.NewGossfile(sr, sys)
	res := NewGossfile(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *GossfileMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Gossfile
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type GroupMap map[string]*Group

func (r GroupMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Group, system.Group) {
	sysres := sys.NewGroup(sr, sys)
	res := NewGroup(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r GroupMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Group, system.Group, bool) {
	sysres := sys.NewGroup(sr, sys)
	res := NewGroup(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *GroupMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Group
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type PackageMap map[string]*Package

func (r PackageMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Package, system.Package) {
	sysres := sys.NewPackage(sr, sys)
	res := NewPackage(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r PackageMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Package, system.Package, bool) {
	sysres := sys.NewPackage(sr, sys)
	res := NewPackage(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *PackageMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Package
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type PortMap map[string]*Port

func (r PortMap) AppendSysResource(sr string, sys *system.System, ignoreList []string, c *cli.Context) (*Port, system.Port) {
	sysres := sys.NewPort(sr, sys, c)
	res := NewPort(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r PortMap) AppendSysResourceIfExists(sr string, sys *system.System, c *cli.Context) (*Port, system.Port, bool) {
	sysres := sys.NewPort(sr, sys, c)
	res := NewPort(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *PortMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Port
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type ProcessMap map[string]*Process

func (r ProcessMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Process, system.Process) {
	sysres := sys.NewProcess(sr, sys)
	res := NewProcess(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r ProcessMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Process, system.Process, bool) {
	sysres := sys.NewProcess(sr, sys)
	res := NewProcess(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *ProcessMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Process
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type ServiceMap map[string]*Service

func (r ServiceMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*Service, system.Service) {
	sysres := sys.NewService(sr, sys)
	res := NewService(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r ServiceMap) AppendSysResourceIfExists(sr string, sys *system.System) (*Service, system.Service, bool) {
	sysres := sys.NewService(sr, sys)
	res := NewService(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *ServiceMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*Service
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go
//go:generate goimports -w resource_list.go resource_list.go

type UserMap map[string]*User

func (r UserMap) AppendSysResource(sr string, sys *system.System, ignoreList []string) (*User, system.User) {
	sysres := sys.NewUser(sr, sys)
	res := NewUser(sysres, ignoreList)
	r[res.ID()] = res
	return res, sysres
}

func (r UserMap) AppendSysResourceIfExists(sr string, sys *system.System) (*User, system.User, bool) {
	sysres := sys.NewUser(sr, sys)
	res := NewUser(sysres, []string{})
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	r[res.ID()] = res
	return res, sysres, true
}

func (r *UserMap) UnmarshalJSON(data []byte) error {
	var tmp map[string]*User
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}

	for id, res := range tmp {
		res.SetID(id)
	}

	*r = tmp

	return nil
}
